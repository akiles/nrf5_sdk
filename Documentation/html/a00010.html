<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF51 SDK: S110 Serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF51 SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00010.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">S110 Serialization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="nrf51_arch_serialization"></a>
Architecture</h1>
<p>The BLE S110 Serialization makes it possible to place a <em>Bluetooth</em> Application on an application chip and connect it to a connectivity chip running the BLE nrf518_lib_ble_s110.</p>
<p><b>Connectivity Chip</b>: The nRF51822 chip running the BLE S110 SoftDevice.<br/>
 <b><em>Bluetooth</em> Application Board:</b> The nRF51822 chip running a serialized application, where the BLE S110 SoftDevice is replaced by the Commands Encoder and Events Decoder. The nRF51822 does not have the BLE S110 SoftDevice.<br/>
</p>
<p>On the <em>Bluetooth</em> Application Board, the BLE S110 SoftDevice is replaced by a codec implementing the S110 SoftDevice API. All function calls to the codec will be serialized and transmitted to the BLE S110 Connectivity Chip using the Transport Layer and UART driver. This design makes it possible to substitute an existing layer, such as UART with SPI, without affecting the codec. <br/>
</p>
<p>The BLE S110 Connectivity Chip will decode the serialized commands from the <em>Bluetooth</em> Application Board and execute the corresponding function in the S110 SoftDevice.<br/>
 Any event from the S110 SoftDevice is encoded by the codec and transmitted to the <em>Bluetooth</em> Application Board using the the transport layer and UART. <br/>
 On the <em>Bluetooth</em> Application Board the event is decoded and passed to the application. <br/>
</p>
<p>BLE S110 Serialization simplifies the serialization of an existing <em>Bluetooth</em> application, since limited modifications are needed in the application itself. Serialization of an existing application requires <a class="el" href="a00993.html">Command Encoder</a>, <a class="el" href="a00995.html">Event Decoder</a>, <a class="el" href="a00941.html">HCI Transport</a> and <a class="el" href="a00944.html">SLIP module</a> which are used in the project instead of the S110 SoftDevice.</p>
<p>See Serialization <a class="el" href="a00093.html#nrf51_setups_serialization">nRFgo Motherboard Setup - Serialization</a> on how to flash and wire a <em>Bluetooth</em> Application Board with a BLE S110 Connectivity chip.</p>
<div class="image">
<img src="architecture_overview_serialization.png" alt="architecture_overview_serialization.png"/>
<div class="caption">
Architectural overview of Serialized &lt;i&gt;Bluetooth&lt;/i&gt; Application.</div></div>
 <h1><a class="anchor" id="nrf51_arch_transport_layer"></a>
HCI Transport Layer</h1>
<p>The BLE S110 Serialization example transmits and receives commands, command responses, and events over UART.</p>
<p>In <em>Bluetooth</em> two UART transport layer protocols are commonly in use.</p>
<ul>
<li><em>Bluetooth</em> Specification 1.1, Part H:4, HCI UART Transport Layer, (known as H4)</li>
<li><em>Bluetooth</em> Specification 4.0, Volume 4, Part D, Three-wire transport layer.</li>
</ul>
<p>The Transport Layer for spec. 1.1, H4, is a very simple and lightweight transport layer, which works very well in noise-free environment and reliable UART.</p>
<p>The Transport Layer for specification 4.0 is more complex and overhead on the wire due to transmission of acknowledgement packets and re-transmissions. The use of acknowledgement packets make the transport layer more robust and reliable but it has associated costs in terms of larger code size, larger memory footprint. It also makes transmission duration longer because of retransmission.</p>
<p>A brief comparison between HCI Transport Layer for specification 1.1 and 4.0 can be seen in the table below.</p>
<table  border="1">
<tr>
<td><b>HCI UART Transport Layer, v 1.1 (H4)</b></td><td><b>HCI Transport Layer, v4.0</b> </td></tr>
<tr>
<td>Simple </td><td>Complex </td></tr>
<tr>
<td>Fast (No ACK packets) </td><td>Slower (ACK packets) </td></tr>
<tr>
<td>Unreliable in noisy environments </td><td>Very reliable (retransmission) </td></tr>
<tr>
<td>Smaller code/memory footprint </td><td>Larger code/memory footprint </td></tr>
</table>
<p>The BLE S110 Serialization examples provides the ability to use the reliable Three-wire Transport Layer, ver. 4.0.</p>
<p>The Three-wire Transport Layer offers reliable transport layer when developing a two chip solution where the nRF51822 is used as the connectivity chip. For the prototyping setup presented in <a class="el" href="a00093.html#nrf51_setups_serialization">nRFgo Motherboard Setup - Serialization</a> , this solution ensures correct transmission and retransmission of packets even when long cables, high baud rates, and noisy environments are taken into consideration. This allows the developer to concentrate on developing the right application without concerns for the communication layer.</p>
<p>It guarantees reliable transfer of packets when connecting the nRF51822 chip to PC UART / USB-UART connectors, which can vary in reliability, especially at higher baud rates.</p>
<p>It is recommended during prototyping and/or early development of nRF51822 product, HCI Transport Layer V4.0 could be used. However after gaining confidence and ensuring robustness and reliability at application level for the final product, it is recommended to switch over to the HCI UART Transport Layer, H4.</p>
<p>The nRF51822 chip offers a reliable UART, even at high baud rates. Therefore acknowledgement of packets and retransmission can be disabled in order to reduce the memory/flash footprint and reduce power consumption. This can be achieved by removing the acknowledgement packets and retransmission from  hci_transport.c .</p>
<h1><a class="anchor" id="nrf51_system_integration_serialization"></a>
HCI - Transport Layer - System integration</h1>
<p>The image below shows the internal architecture of a serialized BLE S110 SoftDevice. </p>
<div class="image">
<img src="connectivity_chip_architecture_serialization.png" alt="connectivity_chip_architecture_serialization.png"/>
<div class="caption">
Internal architecture of a serialized BLE S110 SoftDevice.</div></div>
<p> The image below shows the various threads of execution within the serialized BLE S110 Connectivity Chip. </p>
<div class="image">
<img src="connectivity_chip_priority_contexts_serialization.png" alt="connectivity_chip_priority_contexts_serialization.png"/>
<div class="caption">
Various threads of execution within the serialized BLE S110 Connectivity Chip.</div></div>
<ol type="1">
<li>SoftDevice command decode and event encode context: MAIN priority context<br/>
 1.1 SoftDevice command API call as an output of command decode: MAIN priority context</li>
<li>UART TX/RX ISR calls: APP-LO priority context</li>
<li>hci_transport retransmission timeout context: APP-LO priority context</li>
<li>SoftDevice events: MAIN priority context</li>
</ol>
<p>The image below shows an example internal architecture of an application chip controlling the serialized BLE S110 SoftDevice. </p>
<div class="image">
<img src="application_chip_architecture_serialization.png" alt="application_chip_architecture_serialization.png"/>
<div class="caption">
An example of internal architecture of an application chip.</div></div>
<p> The image below shows an example of various threads of execution which could be executing within an application chip controlling the serialized BLE S110 SoftDevice. </p>
<div class="image">
<img src="application_chip_priority_contexts_serialization.png" alt="application_chip_priority_contexts_serialization.png"/>
<div class="caption">
An example of various threads of execution within the application chip.</div></div>
<ol type="1">
<li>SoftDevice calls: MAIN priority context</li>
<li>UART TX/RX ISR calls: APP-LO priority context</li>
<li>hci_transport retransmission timeout context: APP-LO priority context</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The current application chip reference design has been validated using the priority context setup as defined in the above figure. Any deviation from this model can lead to undefined behavior.</dd></dl>
<p>The image below shows an MSC of a single basic TX path cycle. </p>
<div class="image">
<img src="tx_path_cycle_serialization.png" alt="tx_path_cycle_serialization.png"/>
<div class="caption">
Basic TX path cycle.</div></div>
<ol type="1">
<li>TX codec allocates TX packet memory and issues a packet write request. Request is processed throughout the stack and asynchronous packet write to the UART hardware is started. TX codec receives the status of the request via return code (NRF_SUCCESS), which informs it that a packet was added to the transmission queue and an event will be send upon transmission completion.</li>
<li>TX buffer is eventually transferred completely and a corresponding event gets propagated to hci_transport which will omit propagating it to TX codec until a valid ACK for the TX packet is received.</li>
<li>Valid ACK for TX packet is received, which will complete the TX cycle and is reported to the TX codec.</li>
<li>TX codec received the information of a completed TX cycle and can free the corresponding TX buffer or reuse it for future TX requests.</li>
</ol>
<p>The image below shows an MSC of a TX path cycle where TX path is 1st stopped due TX queue been filled up and after correct event reception resumed. </p>
<div class="image">
<img src="tx_path_queue_full_cycle_serialization.png" alt="tx_path_queue_full_cycle_serialization.png"/>
<div class="caption">
TX path queue full cycle.</div></div>
<ol type="1">
<li>TX codec allocates TX packet memory and issues a packet write request. Request is processed throughout the stack and asynchronous packet write to the UART hardware is started. TX codec receives the status of the request via return code (NRF_SUCCESS), which informs it that a packet was added to the transmission queue and an event will be send upon transmission completion.</li>
<li>TX codec allocates new TX packet memory and issues a new packet write request while the previous request is still in progress. This request will fail (NRF_ERROR_NO_MEM) because the transmission queue is full and the packet was not added. Before issuing this operation again the appropriate event needs to occur.</li>
<li>Valid ACK for the TX packet is received. This completes the TX cycle and is reported to the TX codec which can re-issue the packet write request.</li>
</ol>
<p>The image below shows an MSC of a single basic RX path cycle. </p>
<div class="image">
<img src="rx_path_cycle_serialization.png" alt="rx_path_cycle_serialization.png"/>
<div class="caption">
Basic RX path cycle.</div></div>
<ol type="1">
<li>Free RX memory block is produced by hci_transport and given to hci_slip layer to be used as an RX buffer. RX data is received through the UART, which will be decoded by the hci_slip layer and an event is send to hci_transport layer once a valid slip packet has been received.</li>
<li>Valid RX packet is decoded by hci_transport layer and corresponding ACK packet is written to TX queue (if available space exists otherwise it is discarded). Actual length of the received RX packet is stored to the corresponding RX memory block. New free RX memory block is produced by hci_transport and given to hci_slip layer to be used as RX buffer.</li>
<li>An event is send to the RX codec when a valid RX packet is received. The received packet is extracted and processed by the RX codec allowing the memory to be reused by the hci_transport layer.</li>
</ol>
<p><a class="el" href="a00008.html">BLE S110 Connectivity Chip</a></p>
<p><a class="el" href="a00007.html">Advertising Application Serialized</a></p>
<p><a class="el" href="a00009.html">Heart Rate Application - Serialized</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00004.html">Examples</a></li><li class="navelem"><a class="el" href="a00014.html">BLE Peripheral</a></li>
    <li class="footer">Generated on Thu Mar 13 2014 14:26:57 for nRF51 SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
